# 02 객체들에게 연락 돌리기 : 옵저버 패턴

한 객체(Subject)의 상태가 바뀌면, 그 객체에 의존하는 모든 객체(Observers)들에게 **자동으로 알림을 보내 내용을 갱신**하는 패턴입니다.

핵심 철학은 **"Don't call us, we'll call you"** - Observer가 능동적으로 폴링하지 않아도 Subject가 먼저 호출해줍니다.

---

## 구조

```
┌──────────────────────┐          ┌──────────────────┐
│       Subject        │◄─────────│     Observer     │
│     (주제/발행자)       │  등록/해제 │  (구독자/관찰자)    │
├──────────────────────┤          ├──────────────────┤
│ observers: Observer[]│          │ update(data)     │
│ registerObserver()   │  notify  │                  │
│ removeObserver()     │─────────►│                  │
│ notifyObservers()    │          │                  │
└──────────────────────┘          └──────────────────┘
```

## 핵심 인터페이스

Subject와 Observer를 인터페이스로 분리하는 것이 느슨한 결합의 핵심입니다.

```tsx
// Subject 인터페이스: 구독 관리 + 알림 책임
interface Subject {
  registerObserver(o: Observer): void;
  removeObserver(o: Observer): void;
  notifyObservers(): void;
}

// Observer 인터페이스: 알림 수신 책임
interface Observer {
  update(temp: number, humidity: number, pressure: number): void;
}
```

## 실제 구현: 날씨 스테이션

## Subject 구현체 — WeatherData

```tsx
class WeatherData implements Subject {
  private observers: Observer[] = [];
  private temperature!: number;
  private humidity!: number;
  private pressure!: number;

  registerObserver(o: Observer) {
    this.observers.push(o);
  }

  removeObserver(o: Observer) {
    this.observers = this.observers.filter((obs) => obs !== o);
  }

  notifyObservers() {
    this.observers.forEach((o) =>
      o.update(this.temperature, this.humidity, this.pressure),
    );
  }

  setMeasurements(temp: number, humidity: number, pressure: number) {
    this.temperature = temp;
    this.humidity = humidity;
    this.pressure = pressure;
    this.notifyObservers(); // 변경 → 즉시 알림
  }
}
```

## Observer 구현체 — CurrentConditionsDisplay

```tsx
class CurrentConditionsDisplay implements Observer {
  private temperature!: number;
  private humidity!: number;

  constructor(weatherData: WeatherData) {
    weatherData.registerObserver(this); // 생성 시 자동 구독
  }

  update(temperature: number, humidity: number) {
    this.temperature = temperature;
    this.humidity = humidity;
    this.display();
  }

  display() {
    console.log(`현재 날씨: ${this.temperature}°F, 습도 ${this.humidity}%`);
  }
}
```

## 사용 흐름

```tsx
const weatherData = new WeatherData();

const currentDisplay = new CurrentConditionsDisplay(weatherData); // 자동 구독
const statisticsDisplay = new StatisticsDisplay(weatherData);
const forecastDisplay = new ForecastDisplay(weatherData);

weatherData.setMeasurements(80, 65, 30.4); // ✅ 3개 디스플레이 모두 업데이트
weatherData.setMeasurements(82, 70, 29.2); // ✅ 3개 디스플레이 모두 업데이트

weatherData.removeObserver(forecastDisplay);
weatherData.setMeasurements(62, 90, 28.1); // ✅ 이제 2개만 업데이트
```

---

## 동작 흐름

```
1. Observer  →  registerObserver()  →  Subject에 구독 등록
2. 외부        →  setMeasurements()  →  Subject 상태 변경
3. Subject   →  notifyObservers()   →  알림 트리거
4. Subject   →  observer.update()   →  각 Observer 호출
5. Observer              →              자신의 방식으로 데이터 처리
```

## Push vs Pull

알림 시 데이터를 어떻게 전달할지 결정하는 두 가지 전략입니다.

| 방식     | 코드                                                        | 특징                                                              |
| -------- | ----------------------------------------------------------- | ----------------------------------------------------------------- |
| **Push** | `observer.update(temp, humidity, pressure)`                 | Subject가 모든 데이터 밀어넣기, Observer가 필요없는 데이터도 받음 |
| **Pull** | `observer.update()` 후 `subject.getTemperature()` 직접 조회 | Observer가 필요한 것만 선택해서 가져옴, 더 유연                   |

Observer마다 필요한 데이터가 달라질 수 있으면 Pull이 확장에 유리하고, 이벤트 payload가 명확하면 Push가 단순하다.

- **Push가 더 나은 경우**
  - 이벤트 payload가 명확하고 작을 때 (예: 클릭 좌표, 서버 응답 일부)
  - Subject의 상태를 외부에 “너무 많이” 공개하고 싶지 않을 때 (Pull이면 getter가 늘어남)
- **Pull이 더 나은 경우**
  - Observer마다 관심사가 다르고, 데이터가 자주 바뀌거나 스키마가 변할 때
  - Subject의 update(...) 시그니처가 자주 바뀌는 걸 피하고 싶을 때

## 느슨한 결합 (Loose Coupling)

| Subject가 아는 것            | Subject가 모르는 것                |
| ---------------------------- | ---------------------------------- |
| Observer 목록 (`Observer[]`) | Observer의 구체 클래스             |
| Observer 인터페이스          | Observer가 내부에서 무엇을 하는지  |
| `update()` 메서드 존재       | Observer가 몇 개인지 (런타임 결정) |

- Subject 코드 수정 없이 새 Observer를 자유롭게 추가/제거 가능 → **OCP(개방-폐쇄 원칙) 준수**
- Subject와 Observer는 각자 독립적으로 재사용 가능
- 상호작용은 반드시 인터페이스를 통해서만

## 프론트엔드에서 사용되는 사례

| 구현체                        | Subject                    | Observer                      | 사용처                   |
| ----------------------------- | -------------------------- | ----------------------------- | ------------------------ |
| `addEventListener`            | DOM 노드                   | 이벤트 핸들러 콜백            | 모든 UI 이벤트           |
| `IntersectionObserver`        | 뷰포트 교차 상태           | 콜백 함수                     | 무한 스크롤, lazy load   |
| `MutationObserver`            | DOM 트리 변화              | 콜백 함수                     | 서드파티 DOM 감시        |
| `ResizeObserver`              | 엘리먼트 크기              | 콜백 함수                     | 반응형 컴포넌트          |
| **Redux** `store.subscribe()` | 글로벌 Store               | `useSelector` 컴포넌트        | 상태 관리                |
| **Zustand**                   | `Set<listener>` Store      | 구독 컴포넌트                 | 경량 상태 관리           |
| **MobX** `@observable`        | 필드 단위 자동 추적        | `@observer` 컴포넌트          | 자동 반응형 상태         |
| **Jotai/Recoil** `atom`       | atom 단위                  | `useAtom` 컴포넌트            | 원자 단위 상태           |
| **Vue 3** `reactive()`        | Proxy 객체 (getter/setter) | 렌더 함수                     | 자동 리렌더링            |
| **React Query**               | `QueryCache`               | `QueryObserver` (각 useQuery) | 서버 상태 관리           |
| **RxJS** `Observable`         | 비동기 스트림              | `subscribe` 핸들러            | Angular, 복잡한 비동기   |
| **mitt** / EventBus           | 이벤트 채널 (토픽 기반)    | `emitter.on()` 리스너         | 마이크로 프론트엔드 통신 |

## Observer vs Pub/Sub 차이

Pub/Sub은 Observer 패턴의 발전형으로, 중간에 **Broker(이벤트 버스)**가 추가됩니다.

| 구분       | Observer                     | Pub/Sub                         |
| ---------- | ---------------------------- | ------------------------------- |
| **연결**   | Subject ↔ Observer 직접 참조 | Publisher ↔ Broker ↔ Subscriber |
| **결합도** | 느슨한 결합                  | 완전 분리 (서로 모름)           |
| **채널**   | 단일 (Subject 단위)          | 토픽 기반 다중 채널             |
| **사용처** | 단일 앱 내 컴포넌트 간       | 크로스 앱/마이크로 프론트엔드   |

## 장단점

| 항목          | 내용                                              |
| ------------- | ------------------------------------------------- |
| **목적**      | 1:N 의존성 관리, 상태 변경 자동 알림              |
| **핵심 장점** | OCP 준수, 느슨한 결합, 런타임 동적 구독           |
| **단점**      | 순서 보장 안 됨, Observer 많을수록 성능 저하 가능 |
| **주의**      | 구독 해제 누락 시 메모리 누수                     |

메모리 누수 방지는 React에서 `useEffect` cleanup으로 처리합니다:

```tsx
useEffect(() => {
  const observer = new IntersectionObserver(callback);
  observer.observe(targetRef.current);
  return () => observer.disconnect(); // 반드시 해제
}, []);
```
